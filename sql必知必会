----------------------------------------------------
-- 数据库：表 表名 列 行 主键
----------------------------------------------------

----------------------------------------------------
-- 检索数据：SELECT

-- 单个列
SELECT prod_name
FROM Products;

-- 多个列
SELECT prod_name,prod_id,prod_price
FROM Products;

-- 所有列
SELECT *
FROM Products;

-- 不同值
SELECT vend_id
FROM Products;

SELECT DISTINCT vend_id
FROM Products;

-- 限制结果
SELECT prod_name
FROM Products;

SELECT TOP 5 prod_name
FROM Products;

----------------------------------------------------

----------------------------------------------------
-- 注释
/* 注释
SELECT TOP 5 prod_name
FROM Products;
*/
----------------------------------------------------

----------------------------------------------------
-- 2.9 挑战题
-- 1
SELECT cust_id
FROM Customers;

-- 2
SELECT DISTINCT prod_id
FROM OrderItems;

-- 3
/*
SELECT *
FROM Customers;
*/
SELECT cust_id
FROM Customers;
----------------------------------------------------

----------------------------------------------------
-- 排序检索:ORDER BY

-- 排序数据
SELECT prod_name
FROM Products;

SELECT prod_name
FROM Products
ORDER BY prod_name;
/* ORDER BY 必须为最后的子句 可以通过非检索的列排序数据 */

-- 按多个列排序
SELECT prod_name,prod_id,prod_price
FROM Products;

SELECT prod_name,prod_id,prod_price
FROM Products
ORDER BY prod_price,prod_name;

-- 按列位置排序
SELECT prod_name,prod_id,prod_price
FROM Products
ORDER BY 3,1;

-- 指定排序方向
/* 默认升序A-Z 降序需要指定DESC关键字 DESC只对直接位于其前面的列名 DESC=DESCENDING  */
SELECT prod_name,prod_id,prod_price
FROM Products
ORDER BY prod_price,prod_name;

SELECT prod_name,prod_id,prod_price
FROM Products
ORDER BY prod_price DESC,prod_name;

/* 字典排序时A被视为和a相同 */
----------------------------------------------------

----------------------------------------------------
-- 3.6 挑战题
-- 1
SELECT cust_name
FROM Customers
ORDER BY cust_name DESC;

-- 2
SELECT cust_id,order_num
FROM Orders
ORDER BY cust_id,order_date DESC;

-- 3
SELECT quantity,item_price
FROM OrderItems
ORDER BY quantity DESC,item_price DESC;

-- 4
SELECT vend_name
FROM Vendors
ORDER BY vend_name DESC;

/* error版
SELECT vend_name,
FROM Vendors
ORDER vend_name DESC;
*/
----------------------------------------------------

----------------------------------------------------
-- 过滤数据:WHERE

-- 指定条件搜索/过滤
/* 操作符  =  <>  !=  <  <=  !<  >  >=  !>  BETWEEN  IS NULL  */

-- 检查单个值
SELECT prod_name,prod_price
FROM Products;

SELECT prod_name,prod_price
FROM Products
WHERE prod_price=3.49;

/* 同时使用WHERE和ORDER BY时 先WHERE */

-- 不匹配检查：!=  <>
SELECT vend_id,prod_name
FROM Products
WHERE vend_id != 'DLL01';
/* ''用于限定字符串 值与字符串类型进行比较需要'' 和数值比较不需要 */

-- 范围值检查：BETWEEN
SELECT prod_name,prod_price
FROM Products
WHERE prod_price BETWEEN 5 AND 10;

-- 空值检查：IS NULL
/* NULL=no value 与字段包含0、空字符串、仅仅包含空格不同 */ 
----------------------------------------------------

----------------------------------------------------
-- 3.6
-- 1
SELECT prod_id,prod_name
FROM Products
WHERE prod_price=9.49;

-- 2
SELECT prod_id,prod_name
FROM Products
WHERE prod_price>=9;

-- 3
SELECT DISTINCT order_num
FROM OrderItems
WHERE quantity>=100;

-- 4
SELECT prod_name,prod_price
FROM Products
WHERE prod_price BETWEEN 3 AND 6
ORDER BY prod_price;
----------------------------------------------------

----------------------------------------------------
-- 高级数据过滤
-- 组合WHERE子句
/* 逻辑操作符 AND  OR 在求值顺序中 AND优先级高于OR 可以通过()来对操作符分组 */
SELECT prod_name,prod_price
FROM Products
WHERE vend_id = 'DLL01' OR vend_id = 'BRS01' 
      AND prod_price >=10;

SELECT prod_name,prod_price
FROM Products
WHERE (vend_id = 'DLL01' OR vend_id = 'BRS01') 
      AND prod_price >=10;

/* IN操作符用来指定条件范围 功能与OR相当 但是执行快更清楚且能包含其他SELECT语句 */
SELECT prod_name,prod_price
FROM Products
WHERE vend_id IN ('DLL01','BRS01') 
ORDER BY prod_name;

/* NOT操作符用来否定其后的任何条件 不单用 可以用在要过滤的列前 */
SELECT prod_name
FROM Products
WHERE NOT vend_id = 'DLL01'
ORDER BY prod_name;
----------------------------------------------------

----------------------------------------------------
-- 5.5
-- 1
SELECT vend_name
FROM Vendors
WHERE vend_country = 'USA' AND vend_state = 'CA';

-- 2
SELECT DISTINCT order_num,prod_id,quantity
FROM OrderItems
WHERE quantity>=100 AND prod_id IN ('BR01','BR02','BR03');

-- 3
SELECT prod_name,prod_price
FROM Products
WHERE prod_price >= 3 AND prod_price <= 6
ORDER BY prod_price;

-- 4
SELECT vend_name
FROM Vendors
WHERE vend_country = 'USA' AND vend_state = 'CA'
ORDER BY vend_name;
/* error版
SELECT vend_name
FROM Vendors
ORDER BY vend_name
WHERE vend_country = 'USA' AND vend_state = 'CA';
*/
----------------------------------------------------

----------------------------------------------------
-- 通配符过滤
/* 通配符：用来匹配值的一部分的特殊字符 搜索模式：由字面值、通配符或两者组合构成的搜索条件 */
/* 操作符作为谓词时不是通配符 */
/* 通配符搜索只能用于字符串（文本字段） 非文本数据类型字段不可以 */

-- LIKE操作符

-- %通配符 表示任意字符出现任意次数
SELECT prod_id,prod_name
FROM Products
WHERE prod_name LIKE 'Fish%';
/* 搜索以Fish开头的所有产品 */
/* sql server 搜索不区分大小写 */

SELECT prod_id,prod_name
FROM Products
WHERE prod_name LIKE '%bag%';

SELECT prod_id,prod_name
FROM Products
WHERE prod_name LIKE 'F%y';
/* 放中间适合查找邮箱地址 */
/* %代表搜索模式中给定位置的0个、1个和多个字符 %不匹配NULL */
/* 请注意用来填补字段的空格 */

-- _通配符 只匹配单个字符
SELECT prod_id,prod_name
FROM Products
WHERE prod_name LIKE '_ inch teddy bear';

SELECT prod_id,prod_name
FROM Products
WHERE prod_name LIKE '__ inch teddy bear';

SELECT prod_id,prod_name
FROM Products
WHERE prod_name LIKE '% inch teddy bear';

-- []通配符 用来指定一个字符集 必须匹配指定位置的一个字符
SELECT cust_contact
FROM Customers
ORDER BY cust_contact;

SELECT cust_contact
FROM Customers
WHERE cust_contact LIKE '[JM]%'
ORDER BY cust_contact;

SELECT cust_contact
FROM Customers
WHERE cust_contact LIKE '[^JM]%'
ORDER BY cust_contact;

SELECT cust_contact
FROM Customers
WHERE NOT cust_contact LIKE '[JM]%'
ORDER BY cust_contact;
/* 可以用前缀字符^否定 和 NOT效果相当 */
----------------------------------------------------

----------------------------------------------------
-- 6.4
-- 1
SELECT prod_name,prod_desc
FROM Products
WHERE prod_desc LIKE '%toy%';

-- 2
SELECT prod_name,prod_desc
FROM Products
WHERE NOT prod_desc LIKE '%toy%'
ORDER BY prod_name;

-- 3
SELECT prod_name,prod_desc
FROM Products
WHERE prod_desc LIKE '%toy%' AND prod_desc LIKE '%carrots%';

-- 4
SELECT prod_name,prod_desc
FROM Products
WHERE prod_desc LIKE '%toy%carrots%';
----------------------------------------------------

----------------------------------------------------
-- 创建计算字段
/* 
存储在数据库表中的数据一般不是应用程序所需要的格式 eg. 
 需要显示公司名，同时还需要显示公司的地址，但这两个信息存储在不同的表列中。 
 城市、州和邮政编码存储在不同的列中（应该这样），但邮件标签打印程序需要把它们作为一个有恰当格式的字段检索出来。 
 列数据是大小写混合的，但报表程序需要把所有数据按大写表示出来。 
 物品订单表存储物品的价格和数量，不存储每个物品的总价格（用价格乘以数量即可）。但为打印发票，需要物品的总价格。 
 需要根据表数据进行诸如总数、平均数的计算。 
*/
/* 直接从数据库中检索出转换、计算或格式化过的数据 而不是检索出数据然后再在客户端应用程序中重新格式化 */
/* 计算字段并不实际存在于数据库表中 是运行时在 SELECT 语句内创建的 
基本上与列（column）的意思相同 但数据库列一般称为列 而字段这个术语通常在计算字段这种场合下使用 */

-- 拼接字段：+  ||
SELECT vend_name + '(' + vend_country + ')'
FROM Vendors
ORDER BY vend_name;
/* mysql版
SELECT Concat(vend_name, ' (', vend_country, ')') 
FROM Vendors 
ORDER BY vend_name; 
*/
SELECT RTRIM(vend_name) + '(' + RTRIM(vend_country) + ')'
FROM Vendors
ORDER BY vend_name;
/* RTRIM()函数去除值右边的空格 LTRIM()左边的空格 TRIM()左右两边的空格 */

-- 使用别名：用AS关键字赋予新计算列的名字
SELECT RTRIM(vend_name) + '(' + RTRIM(vend_country) + ')'
 AS vend_title
FROM Vendors
ORDER BY vend_name;
/* 别名的其他用途：包括在实际的表列名包含不合法的字符（如空格）时重新命名它 在原来的名字含混或容易误解时扩充它 */
/* 别名既可以是一个单词 也可以是一个字符串（字符串应该括在引号中） */
/* 别名 = 导出列 */

-- 执行算术计算：+ - * / 
SELECT prod_id,quantity,item_price 
FROM OrderItems 
WHERE order_num = 20008;

SELECT prod_id,quantity,item_price,quantity*item_price AS expanded_price 
FROM OrderItems 
WHERE order_num = 20008; 
/* SELECT 语句为测试、检验函数和计算提供了很好的方法 SELECT省略了FROM子句后就是简单地访问和处理表达式 */
SELECT 3 * 2
SELECT TRIM(' abc ');
SELECT GETDATE()
/* 使用GETDATE函数返回当前日期和时间 */
----------------------------------------------------

----------------------------------------------------
-- 7.5
-- 1
SELECT vend_id,vend_name AS vname,vend_address AS vaddress,vend_city AS vcity
FROM Vendors
ORDER BY vend_name;

-- 2
SELECT prod_id,prod_price,prod_price*0.9 AS sale_price
FROM Products;
----------------------------------------------------

----------------------------------------------------
-- 函数处理数据
-- 函数
/* SQL函数不是可移植的
提取字符串的组成部分：MySQL和SQL Server使用SUBSTRING() 
数据类型转换：MySQL和SQL Server使用CONVERT() 
取当前日期：MySQL使用CURDATE() SQL Server使用GETDATE()
*/
/*
用于处理文本字符串（如删除或填充值 转换值为大写或小写）的文本函数
用于在数值数据上进行算术操作（如返回绝对值 进行代数运算）的数值函数
用于处理日期和时间值并从这些值中提取特定成分（如返回两个日期之差 检查日期有效性）的日期和时间函数
用于生成美观好懂的输出内容的格式化函数（如用语言形式表达出日期 用货币符号和千分位表示金额）
返回DBMS正使用的特殊信息（如返回用户登录信息）的系统函数
*/

-- 文本处理函数
SELECT RTRIM(vend_name) + '(' + RTRIM(vend_country) + ')'
FROM Vendors
ORDER BY vend_name;
/* RTRIM()函数去除值右边的空格 LTRIM()左边的空格 TRIM()左右两边的空格 */
SELECT vend_name,UPPER(vend_name) AS vend_name_upcase 
FROM Vendors 
ORDER BY vend_name; 
/* UPPER()将文本转换为大写 LOWER()小写 */
/* LEFT()返回字符串左边的字符 RIGHT()返回字符串右边的字符 */
/* LENGTH()（也使用DATALENGTH()或LEN()）返回字符串的长度 */
/* SUBSTRING()提取字符串的组成部分 */
SELECT cust_name,cust_contact 
FROM Customers 
WHERE cust_contact = 'Michael Green';

SELECT cust_name, cust_contact 
FROM Customers 
WHERE SOUNDEX(cust_contact) = SOUNDEX('Michael Green'); 
/* SOUNDEX() 返回字符串的SOUNDEX值 将任何文本串转换为描述其语音表示的字母数字模式的算法*/

-- 时间日期处理函数
SELECT order_num 
FROM Orders 
WHERE DATEPART(yy, order_date) = 2020; 
/* DATEPART()函数：返回日期的某一部分 ( ,  )两个参数：返回的成分和从中返回成分的日期 */
/* mysql版
SELECT order_num 
FROM Orders 
WHERE YEAR(order_date) = 2020; 
*/

-- 数值处理函数
/*
ABS() 返回一个数的绝对值 
COS() 返回一个角度的余弦 
EXP() 返回一个数的指数值 
PI() 返回圆周率 π 的值 
SIN() 返回一个角度的正弦 
SQRT() 返回一个数的平方根 
TAN() 返回一个角度的正切 
*/
----------------------------------------------------

----------------------------------------------------
-- 8.4
-- 1
SELECT cust_id,cust_name,UPPER(LEFT([cust_contact],2) + LEFT([cust_city],2)) AS user_login
FROM Customers;

-- 2
SELECT order_num,order_date
FROM Orders
WHERE DATEPART(yy, order_date) = 2020 AND DATEPART(mm, order_date) = 1
ORDER BY order_date;
----------------------------------------------------

----------------------------------------------------
-- 汇总数据
/* eg.
确定表中行数（或者满足某个条件或包含某个特定值的行数）
获得表中某些行的和
找出表列（或所有行或某些特定的行）的最大值、最小值、平均值
*/

-- 聚集函数

SELECT AVG(prod_price) AS avg_price 
FROM Products; 
/* AVG() 返回某列的平均值 忽略列值为 NULL 的行 */

SELECT AVG(prod_price) AS avg_price 
FROM Products 
WHERE vend_id = 'DLL01'; 
/* AVG() 返回某列的特定行的平均值 忽略列值为 NULL 的行 */

SELECT COUNT(*) AS num_cust 
FROM Customers; 
/* COUNT(*)对表中行的数目进行计数 不管表列中包含的是空值（NULL）还是非空值 */ 

SELECT COUNT(cust_email) AS num_cust 
FROM Customers; 
/* COUNT(column)对特定列中具有值的行进行计数 忽略NULL值 */

SELECT MAX(prod_price) AS max_price 
FROM Products; 
/* MAX() 返回某列的最大值 要求指定列名 用于文本数据时返回按该列排序后的最后一行 忽略列值为NULL的行 */

SELECT MIN(prod_price) AS min_price 
FROM Products; 
/* MIN() 返回某列的最小值 要求指定列名 用于文本数据时返回按该列排序后的最前一行 忽略列值为NULL的行 */

SELECT SUM(quantity) AS items_ordered 
FROM OrderItems 
WHERE order_num = 20005; 
/* SUM() 返回某列值之和 忽略列值为NULL的行 */

SELECT SUM(item_price*quantity) AS total_price 
FROM OrderItems 
WHERE order_num = 20005; 
/* 利用标准的算术操作符 所有聚集函数都可用来执行多个列上的计算 */

-- 聚集不同值
/*
对所有行执行计算：指定 ALL 参数或不指定参数
只计算不同的值：指定 DISTINCT 参数
*/
SELECT AVG(prod_price) AS avg_price 
FROM Products 
WHERE vend_id = 'DLL01'; 

SELECT AVG(DISTINCT prod_price) AS avg_price 
FROM Products 
WHERE vend_id = 'DLL01'; 
/* DISTINCT 不能用于 COUNT(*) 必须使用列名 不能用于计算或表达式 */
/* 有的DBMS还支持其他参数 如支持对查询结果的子集进行计算的 TOP 和 TOP PERCENT */

-- 组合聚集函数
SELECT COUNT(*) AS num_items, 
       MIN(prod_price) AS price_min, 
       MAX(prod_price) AS price_max, 
       AVG(prod_price) AS price_avg 
FROM Products; 
----------------------------------------------------

----------------------------------------------------
-- 9.5
-- 1
SELECT SUM(quantity) AS all_sales
FROM OrderItems;

-- 2
SELECT SUM(quantity) AS all_sales
FROM OrderItems
WHERE prod_id = 'BR01';

-- 3
SELECT MAX(prod_price) AS max_price
FROM Products
WHERE prod_price <= 10;
----------------------------------------------------

----------------------------------------------------
-- 分组数据
-- 创建分组 GROUP BY
SELECT vend_id,COUNT(*) AS num_prods 
FROM Products 
GROUP BY vend_id; 
/* 
GROUP BY子句可以包含任意数目的列 可以对分组进行嵌套
在建立分组时 指定的所有列都一起计算（不能从个别的列取回数据）
GROUP BY子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）
如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式 不能使用别名
大多数SQL实现不允许GROUP BY列带有长度可变的数据类型（如文本或备注型字段）
除聚集计算语句外 SELECT语句中的每一列都必须在 GROUP BY子句中给出
如果分组列中包含具有NULL值的行 则NULL将作为一个分组返回 如果列中有多行NULL值 它们将分为一组
GROUP BY子句必须在WHERE子句之后 ORDER BY子句之前
SQL Server在 GROUP BY中支持可选的ALL子句 这个子句可用来返回所有分组 即使是没有匹配行的分组也返回（在此情况下 聚集将返回NULL）
*/

-- 过滤分组 HAVING（类似WHERE WHERE过滤行  HAVING过滤分组 WHERE在数据分组前进行过滤 HAVING在数据分组后进行过滤）
SELECT cust_id,COUNT(*) AS orders 
FROM Orders 
GROUP BY cust_id 
HAVING COUNT(*) >= 2; 

SELECT vend_id, COUNT(*) AS num_prods 
FROM Products 
WHERE prod_price >= 4 
GROUP BY vend_id 
HAVING COUNT(*) >= 2;

SELECT vend_id, COUNT(*) AS num_prods 
FROM Products 
GROUP BY vend_id 
HAVING COUNT(*) >= 2;

-- 分组和排序
/*
ORDER BY 对产生的输出排序 任意列都可以使用
GROUP BY 对行分组 但输出可能不是分组的顺序 只可能使用选择列或表达式列而且必须使用每个选择列表达式 
*/
SELECT order_num,COUNT(*) AS items 
FROM OrderItems 
GROUP BY order_num 
HAVING COUNT(*) >= 3; 

SELECT order_num,COUNT(*) AS items 
FROM OrderItems 
GROUP BY order_num 
HAVING COUNT(*) >= 3 
ORDER BY items, order_num;

-- SELECT子句顺序
/*
SELECT    要返回的列或表达式 是 
FROM      从中检索数据的表   仅在从表选择数据时使用 
WHERE     行级过滤           否 
GROUP BY  分组说明           仅在按组计算聚集时使用 
HAVING    组级过滤           否 
ORDER BY  输出排序顺序       否 
*/
----------------------------------------------------

----------------------------------------------------
-- 10.7
-- 1
SELECT COUNT(*) AS order_line
FROM OrderItems
GROUP BY order_num
ORDER BY order_line;

-- 2
SELECT MIN(prod_price) AS cheapest_item
FROM Products
GROUP BY vend_id
ORDER BY cheapest_item;

-- 3
SELECT order_num
FROM OrderItems
GROUP BY order_num
HAVING SUM(quantity) >= 100;

-- 4
SELECT order_num
FROM OrderItems
GROUP BY order_num
HAVING SUM(item_price*quantity) >= 1000
ORDER BY order_num;

-- 5
SELECT order_num,COUNT(*) AS items 
FROM OrderItems 
GROUP BY order_num
HAVING COUNT(*) >= 3 
ORDER BY items,order_num; 

/* error版
SELECT order_num,COUNT(*) AS items 
FROM OrderItems 
GROUP BY items 
HAVING COUNT(*) >= 3 
ORDER BY items,order_num;
*/
----------------------------------------------------

----------------------------------------------------
-- 使用子查询
-- 子查询：嵌套在其他查询中的查询
-- 利用子查询进行过滤
/* 假如需要列出订购物品 RGAN01 的所有顾客 */
/* (1) 检索包含物品 RGAN01 的所有订单的编号 */
SELECT order_num 
FROM OrderItems 
WHERE prod_id = 'RGAN01'; 
/* (2) 检索具有前一步骤列出的订单编号的所有顾客的 ID */
SELECT cust_id 
FROM Orders 
WHERE order_num IN (20007,20008);
/* (3) 检索前一步骤返回的所有顾客 ID 的顾客信息 */
SELECT cust_name,cust_contact
FROM Customers 
WHERE cust_id IN (1000000004,1000000005);
/* 使用子查询来把 3 个查询组合成一条语句 */
SELECT cust_name,cust_contact
FROM Customers 
WHERE cust_id IN (SELECT cust_id 
                  FROM Orders 
                  WHERE order_num IN (SELECT order_num 
                                      FROM OrderItems 
                                      WHERE prod_id = 'RGAN01'));
/* 作为子查询的SELECT语句只能查询单个列 企图检索多个列将返回错误 */

-- 作为计算字段使用子查询
/* 假如需要显示 Customers 表中每个顾客的订单总数 订单与相应的顾客ID存储在Orders表中 */
/* 
(1) 从 Customers 表中检索顾客列表
(2) 对于检索出的每个顾客 统计其在 Orders 表中的订单数目 
*/
SELECT COUNT(*) AS orders 
FROM Orders 
WHERE cust_id = 1000000001; 

SELECT cust_name,cust_state,(SELECT COUNT(*) 
                               FROM Orders 
                               WHERE Orders.cust_id = Customers.cust_id) AS orders 
FROM Customers 
ORDER BY cust_name;
/* orders是一个计算字段 由圆括号中的子查询建立的 该子查询对检索出的每个顾客执行一次 */
/* 使用完全限定列名 而不只是列名（cust_id） 指定表名和列名（Orders.cust_id和 Customers.cust_id） */
SELECT cust_name,cust_state,(SELECT COUNT(*) 
                             FROM Orders 
                             WHERE cust_id = cust_id) AS orders 
FROM Customers 
ORDER BY cust_name; 
----------------------------------------------------

----------------------------------------------------
-- 11.5
-- 1
SELECT cust_id
FROM Orders
WHERE order_num IN (SELECT order_num
                    FROM OrderItems
                    WHERE item_price >= 10);

-- 2
SELECT cust_id,order_date
FROM Orders
WHERE order_num IN (SELECT order_num
                    FROM OrderItems
		    WHERE prod_id = 'BR01')
ORDER BY order_date;

-- 3
SELECT cust_email
FROM Customers
WHERE cust_id IN (SELECT cust_id
                  FROM Orders
                  WHERE order_num IN (SELECT order_num
                                      FROM OrderItems
				      WHERE prod_id = 'BR01'));

-- 4
SELECT cust_id,(SELECT SUM(item_price*quantity) 
                FROM OrderItems 
                WHERE orders.order_num = orderitems.order_num) AS total_ordered 
FROM Orders
ORDER BY total_ordered DESC; 

-- 5
SELECT prod_name,(SELECT SUM(quantity)
                  FROM OrderItems
		  WHERE orderitems.prod_id = products.prod_id) AS quant_sold
FROM Products;
----------------------------------------------------

----------------------------------------------------
-- 联结表
/* 关系表以及关系数据库设计 可伸缩性好 能够适应不断增加的工作量而不失败 */
/* 联结是一种机制：用来在一条SELECT语句中关联表 使用特殊的语法 可以联结多个表返回一组输出 联结在运行时关联表中正确的行 */

-- 创建联结：指定要联结的所有表以及关联它们的方式
SELECT vend_name,prod_name,prod_price 
FROM Vendors,Products 
WHERE Vendors.vend_id = Products.vend_id; 
/* WHERE子句作为过滤条件：只包含那些匹配给定条件（这里是联结条件）的行 */
/* 由没有联结条件的表关系返回的结果为笛卡儿积 检索出的行的数目将是第一个表中的行数乘以第二个表中的行数 */
SELECT vend_name, prod_name, prod_price 
FROM Vendors, Products;
/* 没有使用WHERE子句的情况 要保证所有联结都有WHERE子句 同时要保证WHERE子句的正确性 */
-- 内联结 = 等值联结：基于两个表之间的相等测试
SELECT vend_name, prod_name, prod_price 
FROM Vendors 
INNER JOIN Products ON Vendors.vend_id = Products.vend_id;
/* 两个表之间的关系是以INNER JOIN指定的部分FROM子句 联结条件用特定的ON子句而不是WHERE子句给出 */
-- 连接多个表
SELECT prod_name,vend_name,prod_price,quantity 
FROM OrderItems,Products,Vendors 
WHERE Products.vend_id = Vendors.vend_id AND OrderItems.prod_id = Products.prod_id AND order_num = 20007; 
/* 不要联结不必要的表 联结的表越多性能下降越厉害 */
/* 子查询 */
SELECT cust_name,cust_contact 
FROM Customers 
WHERE cust_id IN (SELECT cust_id 
                  FROM Orders 
                  WHERE order_num IN (SELECT order_num 
                                      FROM OrderItems 
                                      WHERE prod_id = 'RGAN01')); 
/* 联结表 */
SELECT cust_name,cust_contact 
FROM Customers,Orders,OrderItems 
WHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num AND prod_id = 'RGAN01';
/* 联结的列名相同并不是必需的 */
----------------------------------------------------

----------------------------------------------------
-- 12.4
-- 1
SELECT cust_name,order_num
FROM Customers,Orders
WHERE Customers.cust_id = Orders.cust_id
ORDER BY cust_name,order_num;

SELECT cust_name,order_num
FROM Customers
INNER JOIN Orders ON Customers.cust_id = Orders.cust_id
ORDER BY cust_name,order_num;

-- 2
SELECT cust_name,order_num,(SELECT SUM(item_price*quantity) 
                            FROM OrderItems 
                            WHERE Orders.order_num = Orderitems.order_num) AS OrderTotal
FROM Customers
INNER JOIN Orders ON Customers.cust_id = Orders.cust_id;

SELECT cust_name,Orders.order_num,SUM(item_price*quantity) AS OrderTotal
FROM Customers
INNER JOIN Orders ON Customers.cust_id = Orders.cust_id
INNER JOIN OrderItems ON Orders.order_num = OrderItems.order_num
GROUP BY cust_name,Orders.order_num;
/* 这里为什么要用GROUP BY呢 */

-- 3
/* 11.2
SELECT cust_id,order_date
FROM Orders
WHERE order_num IN (SELECT order_num
                    FROM OrderItems
		            WHERE prod_id = 'BR01')
ORDER BY order_date;
*/
SELECT cust_id,order_date
FROM Orders
INNER JOIN OrderItems ON prod_id = 'BR01' AND Orders.order_num = OrderItems.order_num
ORDER BY order_date;

-- 4
/* 11.3
SELECT cust_email
FROM Customers
WHERE cust_id IN (SELECT cust_id
                  FROM Orders
                  WHERE order_num IN (SELECT order_num
                                      FROM OrderItems
				                      WHERE prod_id = 'BR01'));
*/
SELECT cust_email
FROM Customers
INNER JOIN Orders ON Customers.cust_id = Orders.cust_id
INNER JOIN OrderItems ON Orders.order_num = OrderItems.order_num AND prod_id = 'BR01';

-- 5
SELECT cust_name,SUM(item_price*quantity) AS OrderTotal 
FROM Customers
INNER JOIN Orders ON Customers.cust_id = Orders.cust_id
INNER JOIN OrderItems ON Orders.order_num = OrderItems.order_num
GROUP BY cust_name
HAVING SUM(item_price*quantity) >=1000
ORDER BY cust_name;

SELECT cust_name,SUM(item_price*quantity) AS OrderTotal 
FROM Customers,Orders,OrderItems
WHERE Customers.cust_id = Orders.cust_id AND Orders.order_num = OrderItems.order_num
GROUP BY cust_name
HAVING SUM(item_price*quantity) >=1000
ORDER BY cust_name;
----------------------------------------------------

